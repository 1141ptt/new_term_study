## 南大数据结构

### 求无环链表的平均值

```java
public class Main {
    class ListNode {
        int data;
        ListNode next;
    }
    public float getAverage(ListNode f, int n) {
        if (f.next == null) return f.data;
        else {
            return (getAverage(f.next, n - 1) * (n - 1) + f.data) / n;
        }
    }
}
```

### 判断链表是否有环

```java
public class Main {
    class ListNode {
        int data;
        ListNode next;
    }
    public boolean hasCycle(ListNode head) { // 快慢指针
        if (head == null || head.next == null) return false;
        ListNode p = head, q = head;
        while (q != null && q.next != null) {
            p = p.next; // 快指针一次往后走一步
            q = q.next.next; // 慢指针一次往后走两步
            if (p == q)
                return true;
        }
        return true;
    }
}
```

### 链表反转

```java
public class Main {
    class ListNode {
        int data;
        ListNode next;
    }
    public ListNode reverse(ListNode cur){
        ListNode pre = null;
        while (cur!=null){
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }
}
```

### 输出二叉搜索树不小于给定值k的数

```java
public class Main {
    class BinaryNode {
        int data;
        BinaryNode left;
        BinaryNode right;
    }
    public class BinarySearchTree {
        public BinarySearchTree() {
            root = null;
        }
        public void BSTFind(BinarySearchTree tree, int k) {}
        private BinaryNode root;
    }
    public void BSTFind(BinarySearchTree tree, int k) {
        if (tree) {
            BSTFind(tree.right, k);
            if (tree.data >= k)
                System.out.println(tree.data);
            BSTFind(tree.left, k);
        }
    }
}
```

### 二叉搜索树第k小的结点

```java
public class Main {
    class BinaryNode {
        int data;
        BinaryNode left;
        BinaryNode right;
        int Lsize;
    }
    public BinaryNode findk(int k, BinaryNode t) {
        if (k == t.Lsize)
            return t;
        if (k < t.Lsize)
            return findk(k, t.left);
        if (t.right == null)
            return null;
        else return findk(k - t.Lsize, t.right);
    }
}
```

